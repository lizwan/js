# 4 함수를 자유자재로 휘두르기
> 익명함수가 왜 그렇게 중요한가?

## 4.1 익명 함수

- 익명함수는 함수를 변수에 저장할때
- 객체에 메서드로 설정할때
- 콜백으로 사용할때
- ** 위와 같은 경우 나중에 함수를 참조하기 위함이므로 함수의 이름을 가지고 있을 필요가 없다. **

code.4.1 [익명 함수를 이용하는 일반적인 예제](chapter-4/listing-4.1.html)

- 함수를 정의한 이후에 이름을 사용하지 않기 때문에 함수에 이름을 지정하지 않는다.
- 익명함수를 사용함으로써 함수형언어로서 자바스크립트를 사용해야 한다.
- 불필요한 함수의 이름으로 전역 네임스페이스를 오염시키지 않는다.
- 명령형 구문으로 가득찬 큰 함수를 만드는 대신 인자로 전달하는 작은 함수를 만든다.
- 함수의 활용범위와 함수를 활용한 다양한 코딩 방법을 살펴본다.

## 4.2 재귀
### 4.2.1 이름을 가진 함수 내에서의 재귀
- 재귀적으로 호출하는 함수이름

      function chirp(n) {                                      //#1
        return n > 1 ? chirp(n - 1) + "-chirp" : "chirp";      //#1
      }  

code.4.2 [이름을 가진 함수를 이용해서 소리내기](chapter-4/listing-4.2.html)

### 4.2.2 메서드를 이용한 재귀
- 재귀 함수가 객체의 프로퍼티에 할당된 익명 함수가 된다.
- 재귀적으로 호출하는 함수 참조가 객체의 프로퍼티(함수를 메서드로 호출)

```
      var ninja = {             //재귀 함수인 chirp를 ninja 객체의 프로퍼티로 선언한다.
        chirp: function(n) {
          return n > 1 ? ninja.chirp(n - 1) + "-chirp" : "chirp"; //메서드 내에서 객체의 참조(ninja.chirp)를 이용해서 메서드를 호출
        }
      };
```
code.4.3 [객체 내에서 매서드 재귀 호출](chapter-4/listing-4.3.html)

`
? code.4.2 와 code.4.3의 차이점은?
-> 함수의 이름 호출과 객체 프로퍼티 호출의 차이
`

### 4.2.3 참조가 사라지는 문제
- 함수이름으로 호출하는것과는 다르게 참조할 경우는 (callByValue, callByReference) 사라질수 있다.

code.4.4 [사라진 함수 참조를 이용하는 재귀호출](chapter-4/listing-4.4.html)

- 익명 함수 내에서 명시적으로 ninja를 참조하는 대신, 다음과 같이 함수의 context인 this를 사용해야 한다.

```
      var ninja = {
        chirp: function(n) {
          return n > 1 ? this.chirp(n - 1) + "-chirp" : "chirp";
        }
      };
```
- 함수를 객체의 메서드로써 호출하면(ninja.chirp(n - 1)) 함수의 context는 메서드가 호출된 객체를 가르킨다.
- 함수의 컨텍스트를(this) 이용하면 문제가 해결되는듯 하나...

```
자바스크립트의 Context, Closure, this 
http://incn.tistory.com/89
```

### 4.2.4 이름을 가진 인라인 함수
- 앞에서 함수를 객체의 메서드로 이용하는경우임.
- 메서드를 소유한 객체를 참조하기 위해서 함수의 컨텍스트를 활용하는 방법은 늘 하던 방법임.
- 그러나 문제
  - 문제 1. 프로퍼티 이름이 chirp가 아니라면 어떻게 되나?
  - 문제 2. 함수를 가르키는 참조가 객체의 프로퍼티가 아니라면 어떻게 되나? 
- 이름을 가진 익명함수 === 인라인 함수 를 이용해 이문제를 해결해보자

code.4.5 [재귀호출에서 인라인 함수를 이용하기]()

`왜 잘되는지?`

code.4.6 [인라인 함수의 동일성 검증하기](chapter-4/listing-4.6.html)

- 인라인 함수의 이름은 변수의 이름과 유사하게 동작하고, 인라인 함수에 지정된 이름은 해당 함수의 내부에서만 사용가능
- 이런 이유때문에 최상위 함수는 window 객체의 메서드가 되도록 만든다. window 객체 프로퍼티가 아니고서는 최상위 함수들을 참조할 수 없기 때문에 (window.onload)
- 인라인 함수를 이용하면 this를 이용한 것 보다 더 명료한 방법임은 분명하나 이 방법 또한 외부에서 참조가 안되는 단점이 있다. 다른 방법은 없나?...

### 4.2.5 callee 프로퍼티
- callee는 ECMAScript5 표준 'strict'모드에서 금지

code.4.7 [현재 호출된 함수를 참조하기 위해서 arguments.callee를 활용하기](chapter-4/listing-4.7.html)

- callee프로퍼티를 이용하면 항상 안정적으로 함수 자체를 참조할 수 있다.

`결론적으로 함수 참조를 하려면 callee 를 사용하면 되는건가?`

### 4.3.1 함수 저장하기
code.4.8 [서로 다른 함수를 컬렉션에 저장하기](chapter-4/listing-4.8.html)

## 4.4 가변인자 목록
### 4.4.1 apply() 메서드를 이용해서 가변길이의 인자를 전달하기
- javascript에서는 최소값, 최대값을 검색하는 기능이 없다.
- Math 객체에 있는 min(), max() 로 유사하게 구현 가능

```
var biggest = Math.max(1,2);
var biggest = Math.max(1,2,8,9,10,2058);
var biggest = Math.max(list[0], list[1],list[2]);
```
- max 대신 apply 
- 모든 함수가 지니고 있는 call, apply
- code.4.11 [배열을 인자로 받는 제네릭 main(), max() 함수](chapter-4/listing-4.11.html)
- 함수를 호출할때 가변인자 목록을 사용하는 방법

### 4.4.2 함수 오버로딩
- 가변인자를 전달받는 함수를 선언하는 방법
- java : 이름은 같지만 다른 매개변수 목록을 갖는 메서드 구현을 선언하는 방식
- javascript : 전달된 인자의 수와 유형에 따라 동작방식이 변경되는 단일 함수를 이용해서 함수를 오버로드 한다.
- code.4.12 [가변인자 목록 순회하기](chapter-4/listing-4.12.html)
- 인자의 컬렉션에 접근하고 순회하는 기능은 복잡하고 똑똑한 메서드를 만드는 강력한 수단이다.
- 어떤값이 전달될지 미리 알 수 없는 상황이라 하더라도 유연하게 동작하는 함수를 만들기 위해서 함수에 전달된 인자를 검사 하는데 argument collection을 활용할 수 있다.
- 예를 들면 Jquery UI 서로 다른 인자

```
$("#myDialog").dialog({caption: " This is a dialog" });
$("#myDialog").dialog("open");
```
### 4.4.3 함수의 오버로딩에 대한 접근방법
#### 4.4.3.1 함수의 length 프로퍼티
- 함수가 어떻게 선언되었는지에 대해 알 수 있게 해준다.
- 함수를 선언할 때 지정한, 이름을 가진 매개변수의 수가 저장되어 있다.
- arguments 의 length 프로퍼티와는 다르다.
- 결과적으로 함수 내에서 함수 인자에 대해 두 가지를 알 수 있다.
  - length 프로퍼티를 통해서 이름을 지닌 매개변수의 수를 알수 있다.
  - arguments.length를 통해서 호출 시에 전달된 인자의 수를 알수 있다.

#### 4.4.3.2 인자의 개수를 이용한 함수 오버로딩
- 함수의 인자를 기반으로 오버로드를 결정하는 3가지 방법
  1. 전달된 인자의 타입에 근거해서 다른 연산을 실행
  2. 특정 매개변수의 존재 유무에 따라 전환을 하는것
  3. 전달된 인자의 수를 이용하는 것

```
var ninja = {
  whatever: function() {
  	swich (argument.length) {
  		case 0 : /* something */
  	break;
  		case 1 :
  	break;
  		case 2 : 
  	break;
  	}
  }
}
```

- code.4.15 [메서드 오버로딩을 처리하는 함수](chapter-4/add-method.js)
